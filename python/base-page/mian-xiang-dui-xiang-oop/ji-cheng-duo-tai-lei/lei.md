# 类

## 1 类的结构

### 1.1 术语 -- 实例

1. 使用面向对象开发，**第 1 步** 是设计 **类**
2. 使用 **类名()** 创建对象，**创建对象** 的动作有两步：
   * 在内存中为对象 **分配空间**
   * 调用初始化方法 `__init__` 为 **对象初始化**
3. 对象创建后，**内存** 中就有了一个对象的 **实实在在** 的存在 —— **实例**

<figure><img src="../../../../.gitbook/assets/017_类的结构示意图I.png" alt=""><figcaption><p>类的结构示意图</p></figcaption></figure>

因此，通常也会把：

1. 创建出来的 **对象** 叫做 **类** 的 **实例**
2. 创建对象的 **动作** 叫做 **实例化**
3. **对象的属性** 叫做 **实例属性**
4. **对象调用的方法** 叫做 **实例方法**

在程序执行时：

1. 对象各自拥有自己的 **实例属性**
2. 调用对象方法，可以通过 `self.`
   * 访问自己的属性 、 调用自己的方法

**结论**

* **每一个对象** 都有自己 **独立的内存空间**，**保存各自不同的属性**
* **多个对象的方法**，**在内存中只有一份**，在调用方法时，**需要把对象的引用** 传递到方法内部

### 1.2 类是一个特殊的对象

> python 中 一切皆对象：\
> `class AA:` 定义的类属于 类对象\
> `obj1 = AA()` 属于实例对象

在程序运行时， 类 同样 会被加载到内存

在程序运行时，类对象 在内存中 只有一份，使用 一个类 可以创建出 很多个对象实例

除了封装 **实例** 的 **属性** 和 **方法**外，**类对象** 还可以拥有自己的 **属性** 和 **方法**

通过 **类名.** 的方式可以 **访问类的属性** 或者 **调用类的方法**

<figure><img src="../../../../.gitbook/assets/017_类的结构示意图II.png" alt=""><figcaption><p>类的结构示意图</p></figcaption></figure>

## 2 类属性和实例属性

### 2.1 概念和使用

* **类属性** 就是给 **类对象** 中定义的 **属性**
* 通常用来记录 **与这个类相关** 的特征
* **类属性** **不会用于**记录 **具体对象的特征**

#### 2.1.1 示例

定义一个工具类，每件工具都有自己的 name，看看创建了多少个工具对象

```python
class Tool(object):
    # 使用赋值语句， 定义类属性，记录创建工具对象的总数
    
    count=0
    
    def __init__(self,name):
        
        self.name = name
        
        # 针对类属性做一个计数 +1
        
        Tool.count +=1
 
# 创建工具对象
tool1 = Tool("斧头")
tool1 = Tool("榔头")
tool1 = Tool("铁锹")     

# 知道使用 Tool 类到底创建了多少个对象?
print("现在创建了 %d 个工具" % Tool.count)
```

### 2.2 属性的获取机制

属性的获取 存在一个 向上查找机制

<figure><img src="../../../../.gitbook/assets/019_通过对象访问类属性.png" alt=""><figcaption><p>通过对象访问类属性</p></figcaption></figure>

要访问类的属性方式： <mark style="color:yellow;">`类名.类属性`</mark> \
不推荐： 对象.类属性

* 如果使用 `对象.类属性 = 值` 赋值语句，只会 **给对象添加一个属性**，而不会影响到 **类属性的值**

## 3 类方法和静态方法

### 3.1 类方法

**类属性** 就是针对 **类对象** 定义的属性

* 使用 **赋值语句** 在 `class` 关键字下方可以定义 **类属性**
* **类属性** 用于记录 与这个类相关的特征

**类方法** 就是针对 **类对象** 定义的方法

* 在 **类方法** 内部可以直接访问 **类属性** 或者调用其他的 **类方法**

```python
@classmethod
def 类方法名(cls):
    pass
```

* 类方法需要用 **修饰器** `@classmethod` 来标识，**告诉解释器这是一个类方法**
* 类方法的 **第一个参数** 应该是 `cls`

通过 **类名.** 调用 **类方法**，**调用方法时**，不需要传递 `cls` 参数

**在方法内部**

* 可以通过 `cls.` **访问类的属性**
* 也可以通过 `cls.` **调用其他的类方法**

#### 3.1.1 示例

要求：定义一个工具，有自己的 name ， 需求封装一个 `show_tool_count` 类方法，输出使用当前这个类，创建的对象个数。

```python
@classmethod
def show_tool_count(cls):
    """显示工具对象的总数"""
    print("工具对象的总数 %d" % cls.count)
```

### 3.2 静态方法

如果需要在 类 中封装一个方法，这个方法 既不需要访问  实例属性或者调用 实例方法；也不需要访问 类属性 或者调用类方法。

```python
@staticmethod
def 静态方法名():
    pass
```

```python
class Dog(object):
    
    @staticmethod
    def run():
        
        # 不访问实例属性/类属性
        print("小狗要跑")
        
Dog.run()
```
